\documentclass{article}

\usepackage{polyglossia}
\usepackage{xcolor}
\usepackage{fontspec}
\usepackage{mathtools}
\usepackage{graphicx}
\setdefaultlanguage{french}
\setlength{\parskip}{4pt}
\newtheorem{definition}{Définition}

\begin{document}

\section{Introduction}

\subsection{Trois points de vue sur la notation objet}

\begin{itemize}
	\item Abstraction (type abstrait) - point de vue structure
		\begin{itemize}
			\item Cache les structures (ex: pile) par les manipulations légales (ex: empiler,
dépiler)
			\item On parle \emph{d'encapsulation} de l'objet
		\end{itemize}
	\item Réseaux sémantiques (Intelligence artificielle) - point de vue concept
	\begin{itemize}
		\item Sous classe SC \emph{est une sorte de classe} C
		\item Objet O \emph{est un (est une instance)} de C
	\end{itemize}
	\item Langage d'acteurs (Intelligence artificielle) - point de vue dynamique
	\begin{itemize}
		\item l'objet O reçoit un message et y réagit
		\item Système multi-agents
	\end{itemize}
\end{itemize}

\subsection{Trois grandes classes d'applications}

\begin{itemize}
	\item La conception = représenter le monde réel pour l'informatiser
	\begin{itemize}
		\item Représente les entités (classe) et les liens (héritage) naturellement
		\item Visualisation facile (graphe des classes) synthèse et modifications
	\end{itemize}
	\item La programmation = le codage
	\begin{itemize}
		\item La programmation jaillit de la modélisation
		\item Les fonctions sont relatives aux données
		\item Un même nom de fonction pour même opération, même si codage
différent (langage abstrait)
	\end{itemize}
	\item Les bases de données = la persistance
	\begin{itemize}
		\item Pourquoi utiliser des tables ?
		\item Objets persistants
	\end{itemize}
\end{itemize}

\subsection{Principes}

\begin{itemize}
\item Principe 1 : on raccroche à la structure de données (champs),
les codes qui peuvent les manipuler (méthode) -> classe
\item Principe 2 : on hiérarchise les classes -> héritage
\item Principe 3 : on assure la sécurité des accès aux données et
méthodes sous forme d’autorisation; on gère les erreurs
\end{itemize}

\section{Propriétés des accès}
Qui peut accéder aux champs, méthodes et classes ?

\subsection{Le constructeur}
\begin{itemize}
	\item Appliqué à une classe retourne un objet de la classe
	\begin{itemize}
		\item Créer un objet à partir d'une classe
		\item Initialiser l'objet par les valeurs adéquates (initialiser 
		après le new les champs)
	\end{itemize}
	\item Programmer des constructeurs paramétrés
	\begin{itemize}
		\item (LOLO): nomClasse <= new(val1,..,valn)
		\item (en JAVA): définir des méthodes du nom de la classe
		\begin{itemize}
			\item Quand aucun constructeur n'est défini -> constructeur par défaut
			\item Le constructeur par défaut est désactivé dès qu'il existe un 
				constructeur programmé
			\item On peut reconstruire à la main un constructeur sans paramètre
		\end{itemize}
	\end{itemize}
	\item L'utilisation de \emph{super}
	\begin{itemize}
		\item super() appel le constructeur de la sur-classe
		\item super.méthode(\dots) appel de méthode de la classe supérieur
	\end{itemize}
\end{itemize}

\subsection{Accès privé/public}

L'accès à un champs peut être : 
\begin{itemize}
	\item \textbf{privé} : seules les méthodes de la classe C peuvent utiliser
le champs
	\item \textbf{public} : tout code (ayant accès à la classe C) peut l’utiliser
	\item \textbf{protégé} : seules les méthodes de la classe C et de ses sous
classes peuvent utiliser le champs
\end{itemize}

Règles :
\begin{itemize}
	\item un champs est généralement privé
	\item --> accès par des méthodes adéquates
	\item un champs gérant des données d'implémentation est privé
\end{itemize}

L'accès aux méthodes m dd'une classe C peut être :
\begin{itemize}
	\item \textbf{privé} : seules les méthodes de la classe C peuvent utiliser m
	\item \textbf{public} : tout code (ayant accès à la classe C) peut utiliser m
	\item \textbf{protégé} : seules les méthodes de la classe C et de ses sous classes
peuvent utiliser m 
\end{itemize}

Remarques :
\begin{itemize}
	\item \emph{private, public, protected} (en JAVA) sont appelés des
modificateurs (d'accès)
	\item Accesseurs (conventions)
	\begin{itemize}
		\item \emph{getVar} : accès lecture à un champs \emph{Var}
		\item \emph{setVar} : accès écriture à un champs \emph{Var}
	\end{itemize}
\end{itemize}

On parle de portée d'une déclaration

\subsection{Les paquetages}

Un paquetage, en JAVA, n'existe pas en Smalltalk ou C++

\begin{itemize}
	\item Idées
	\begin{itemize}
		\item pour de grandes applications
		\item regroupe des classes dans un paquetage (\emph{package} en JAVA)
		\item Nom de la classe, référé à un paquetage (permet 2 classes de même nom)
		\item  Les paquetages organisent logiquement les classes dans une hiérarchie;
	généralement, l’organisation physique est la même
	\end{itemize}
	\item Principes du package (logique) et de son positionnement système (physique)
	\begin{itemize}
		\item Un package est associé à un répertoire :le nom du pakage est celui du
répertoire
		\item Une hiérarchie de packages correspond à une hiérarchie de répertoires
		\item Dans un package, il y a des classes, et des sous packages (= sous répertoires)
		\item Le premier niveau de hiérarchie correspond au nom de l’application ou du
propriétaire (ex: loiseau, java)
	\end{itemize}
	\item Principes de nommage, d’appartenance et de recherche
	\begin{itemize}
		\item un mécanisme de nommage : \emph{nomPackage.nomSousPackage.NomClasse}
		\item appartenance :
			\begin{itemize}
				\item Par défaut: une classe dans un répertoire appartient au package 
					correspondant
				\item Par déclaration: package nomPackage.nomSousPackage (1ere instr)
			\end{itemize}
		\item recherche : variable \emph{CLASSPATH} (Windows)
	\end{itemize}
	\item Accès aux classes d’un package
	\begin{itemize}
		\item les classes (object, String...) du package java.lang sont utilisables
	dans toute classe
		\item pour importer une classe C ou un packetage P dans un programme :
	import C et  import P.* en tête de fichier
		\item Si pas de modificateur de champs et méthode: toutes les classes du package y
	ont accès
		\item Attention : Modificateur d'accès d'une classe C,  
			\emph{public} : la classe est accessible en dehors du package où elle est définie
		pas de modificateur: seules les classes du même paquetage ont accès à C
	\end{itemize}
\end{itemize} 

\section{Les classes pour elles-même}

\subsection{Retour à l'héritage}

\begin{itemize}
	\item l'autoréférencement
	\begin{itemize}
		\item pour appliquer une méthode à l'objet
		\item pour lever l'ambiguïté entre nom de champs et variable
	\end{itemize}
	\item L'option \emph{final} (sécurité)
	\begin{itemize}
		\item une méthode \emph{final} ne peut pas être redéfinie dans une sous classe
		\item une classe définie \emph{final} ne peut pas être héritée
		\item une variable \emph{final} est une constante
	\end{itemize}
\end{itemize}

\subsection{Classe abstraite}

\begin{definition}
	Une classe abstraite est une classe pour laquelle il ne peut
exister d'instances.
\end{definition}

\begin{itemize}
	\item elle factorise les champs et méthodes de sous classes
	\item elle est déclarée avec le mot clef \emph{abstraite} (abstract)
\end{itemize}

\begin{definition}
	Une méthode abstraite d'une classe C est une méthode ne
possédant pas de corps. La méthode doit être implémentée dans chaque
sous-classe de la classe C
\end{definition}

\begin{itemize}
	\item elle est redéfinie au niveau des sous classes
	\item vérification à la compilation des redéfinitions obligatoires dans les
	sous-classes
	\item elle est déclarée avec le mot clef \emph{abstraite (abstract)}
	\item Vérification : Si C a une méthode abstraite => C est abstraite
\end{itemize}

\subsection{Variables de classe et méthodes de classe}

\begin{definition}
	Une variable de classe est une variable rattachée à la classe.
\end{definition}

\begin{definition}
	Une méthode de classe est une méthode qui s'applique à la classe.
\end{definition}

\end{document}

